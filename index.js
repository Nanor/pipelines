// Generated by CoffeeScript 1.10.0
(function() {
  var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  $(document).ready(function() {
    var DOWN, Grid, LEFT, Machine, RIGHT, UP, grid;
    UP = 'up';
    RIGHT = 'right';
    DOWN = 'down';
    LEFT = 'left';
    Grid = (function() {
      function Grid(width, height, element1) {
        var cell, dir, j, k, l, len, ref, ref1, ref2, row, x, y;
        this.width = width;
        this.height = height;
        this.element = element1;
        this.machines = (function() {
          var j, ref, results;
          results = [];
          for (j = 1, ref = this.width * this.height; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--) {
            results.push(null);
          }
          return results;
        }).call(this);
        this.edges = (function() {
          var j, ref, results;
          results = [];
          for (j = 1, ref = this.width + this.height + 2 * this.width * this.height; 1 <= ref ? j <= ref : j >= ref; 1 <= ref ? j++ : j--) {
            results.push(null);
          }
          return results;
        }).call(this);
        for (y = j = 0, ref = this.height; 0 <= ref ? j <= ref : j >= ref; y = 0 <= ref ? ++j : --j) {
          row = $('<div/>', {
            "class": 'row'
          });
          for (x = k = 0, ref1 = this.width; 0 <= ref1 ? k <= ref1 : k >= ref1; x = 0 <= ref1 ? ++k : --k) {
            cell = $('<div/>', {
              "class": 'cell'
            });
            if (x < this.width && y < this.height) {
              cell.append($('<div/>', {
                "class": 'slot',
                id: 'slot' + this.toMachineIndex(x, y)
              }));
            }
            ref2 = [LEFT, UP];
            for (l = 0, len = ref2.length; l < len; l++) {
              dir = ref2[l];
              cell.append($('<div/>', {
                "class": 'number',
                id: 'number' + this.toEdgeIndex(x, y, dir)
              }));
            }
            row.append(cell);
          }
          this.element.append(row);
        }
      }

      Grid.prototype.getMachine = function(x, y) {
        return this.machines[this.toMachineIndex(x, y)];
      };

      Grid.prototype.setMachine = function(x, y, value) {
        var index, slot;
        index = this.toMachineIndex(x, y);
        this.machines[index] = value;
        slot = $('#slot' + index);
        slot.find('.machine').remove();
        slot.append(this.machines[index].paint());
        return this.machines[index];
      };

      Grid.prototype.toMachineIndex = function(x, y) {
        return x + y * this.width;
      };

      Grid.prototype.getEdge = function(x, y, dir) {
        return this.edges[this.toEdgeIndex(x, y, dir)];
      };

      Grid.prototype.setEdge = function(x, y, dir, value) {
        var edge_index;
        edge_index = this.toEdgeIndex(x, y, dir);
        this.element.find('#number' + edge_index).text(value != null ? value : '');
        return this.edges[edge_index] = value;
      };

      Grid.prototype.toEdgeIndex = function(x, y, dir) {
        if (dir === UP) {
          return (x + y * (this.width + 1)) * 2 + 1;
        } else if (dir === LEFT) {
          return (x + y * (this.width + 1)) * 2;
        } else if (dir === RIGHT) {
          return this.toEdgeIndex(x + 1, y, LEFT);
        } else if (dir === DOWN) {
          return this.toEdgeIndex(x, y + 1, UP);
        }
      };

      Grid.prototype.update = function() {
        var dir, i, j, jammed, k, l, len, m, machine, ref, ref1, ref2, ref3, results, supplied, value, x, y;
        for (x = j = 0, ref = this.width; 0 <= ref ? j < ref : j > ref; x = 0 <= ref ? ++j : --j) {
          for (y = k = 0, ref1 = this.height; 0 <= ref1 ? k < ref1 : k > ref1; y = 0 <= ref1 ? ++k : --k) {
            machine = this.getMachine(x, y);
            if (machine != null) {
              if (machine.contents == null) {
                supplied = true;
                ref2 = machine.inputs;
                for (l = 0, len = ref2.length; l < len; l++) {
                  value = ref2[l];
                  if (this.getEdge(x, y, value) == null) {
                    supplied = false;
                  }
                }
                if (supplied) {
                  machine.contents = (function() {
                    var len1, m, ref3, results;
                    ref3 = machine.inputs;
                    results = [];
                    for (m = 0, len1 = ref3.length; m < len1; m++) {
                      dir = ref3[m];
                      value = this.getEdge(x, y, dir);
                      this.setEdge(x, y, dir, null);
                      results.push(value);
                    }
                    return results;
                  }).call(this);
                  machine.contents = machine["function"](machine.contents);
                }
              }
            }
          }
        }
        results = [];
        for (x = m = 0, ref3 = this.width; 0 <= ref3 ? m < ref3 : m > ref3; x = 0 <= ref3 ? ++m : --m) {
          results.push((function() {
            var len1, len2, n, o, p, ref4, ref5, ref6, results1;
            results1 = [];
            for (y = n = 0, ref4 = this.height; 0 <= ref4 ? n < ref4 : n > ref4; y = 0 <= ref4 ? ++n : --n) {
              machine = this.getMachine(x, y);
              if (machine != null) {
                if (machine.contents != null) {
                  jammed = false;
                  ref5 = machine.outputs;
                  for (o = 0, len1 = ref5.length; o < len1; o++) {
                    value = ref5[o];
                    if (this.getEdge(x, y, value)) {
                      jammed = true;
                    }
                  }
                  if (!jammed) {
                    ref6 = machine.contents;
                    for (i = p = 0, len2 = ref6.length; p < len2; i = ++p) {
                      value = ref6[i];
                      this.setEdge(x, y, machine.outputs[i], value);
                    }
                    results1.push(machine.contents = null);
                  } else {
                    results1.push(void 0);
                  }
                } else {
                  results1.push(void 0);
                }
              } else {
                results1.push(void 0);
              }
            }
            return results1;
          }).call(this));
        }
        return results;
      };

      return Grid;

    })();
    Machine = (function() {
      function Machine(inputs, outputs, _function) {
        this.inputs = inputs != null ? inputs : [];
        this.outputs = outputs != null ? outputs : [];
        this["function"] = _function != null ? _function : (function(i) {
          return i;
        });
        this.contents = null;
      }

      Machine.prototype.paint = function() {
        var dir, element, j, k, len, len1, list, name, ref, ref1, ref2;
        element = $('<div/>', {
          "class": 'machine'
        });
        ref = [[this.inputs, 'input'], [this.outputs, 'output']];
        for (j = 0, len = ref.length; j < len; j++) {
          ref1 = ref[j], list = ref1[0], name = ref1[1];
          ref2 = [UP, DOWN, LEFT, RIGHT];
          for (k = 0, len1 = ref2.length; k < len1; k++) {
            dir = ref2[k];
            if (indexOf.call(list, dir) >= 0) {
              element.append($('<div/>', {
                "class": 'port ' + name + ' ' + dir
              }));
            }
          }
        }
        return element;
      };

      return Machine;

    })();
    grid = new Grid(5, 5, $('.grid'));
    grid.setMachine(1, 1, new Machine([], [DOWN], function() {
      if (this.t != null) {
        return this.t = null;
      } else {
        return this.t = [Math.floor(Math.random() * 10)];
      }
    }));
    grid.setMachine(1, 2, new Machine([UP], [DOWN, RIGHT], function(i) {
      return i.concat(i);
    }));
    grid.setMachine(2, 2, new Machine([LEFT], [DOWN], function(i) {
      return i.map(function(a) {
        return a * 2;
      });
    }));
    grid.setMachine(1, 3, new Machine([UP], [RIGHT]));
    grid.setMachine(2, 3, new Machine([UP, LEFT], [RIGHT], function(i) {
      return [
        i.reduce(function(a, b) {
          return a + b;
        })
      ];
    }));
    grid.setMachine(3, 3, new Machine([LEFT]));
    return setInterval(function() {
      return grid.update();
    }, 1000);
  });

}).call(this);

//# sourceMappingURL=index.js.map
